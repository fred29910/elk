// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/masseelch/elk/internal/pets/ent/badge"
	"github.com/masseelch/elk/internal/pets/ent/pet"
	"github.com/masseelch/elk/internal/pets/ent/playgroup"
	"github.com/masseelch/elk/internal/pets/ent/predicate"
	"github.com/masseelch/elk/internal/pets/ent/toy"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBadge     = "Badge"
	TypePet       = "Pet"
	TypePlayGroup = "PlayGroup"
	TypeToy       = "Toy"
)

// BadgeMutation represents an operation that mutates the Badge nodes in the graph.
type BadgeMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	color         *badge.Color
	material      *badge.Material
	clearedFields map[string]struct{}
	wearer        *int
	clearedwearer bool
	done          bool
	oldValue      func(context.Context) (*Badge, error)
	predicates    []predicate.Badge
}

var _ ent.Mutation = (*BadgeMutation)(nil)

// badgeOption allows management of the mutation configuration using functional options.
type badgeOption func(*BadgeMutation)

// newBadgeMutation creates new mutation for the Badge entity.
func newBadgeMutation(c config, op Op, opts ...badgeOption) *BadgeMutation {
	m := &BadgeMutation{
		config:        c,
		op:            op,
		typ:           TypeBadge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBadgeID sets the ID field of the mutation.
func withBadgeID(id uint32) badgeOption {
	return func(m *BadgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Badge
		)
		m.oldValue = func(ctx context.Context) (*Badge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Badge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBadge sets the old Badge of the mutation.
func withBadge(node *Badge) badgeOption {
	return func(m *BadgeMutation) {
		m.oldValue = func(context.Context) (*Badge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BadgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BadgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Badge entities.
func (m *BadgeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BadgeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BadgeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Badge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetColor sets the "color" field.
func (m *BadgeMutation) SetColor(b badge.Color) {
	m.color = &b
}

// Color returns the value of the "color" field in the mutation.
func (m *BadgeMutation) Color() (r badge.Color, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldColor(ctx context.Context) (v badge.Color, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *BadgeMutation) ResetColor() {
	m.color = nil
}

// SetMaterial sets the "material" field.
func (m *BadgeMutation) SetMaterial(b badge.Material) {
	m.material = &b
}

// Material returns the value of the "material" field in the mutation.
func (m *BadgeMutation) Material() (r badge.Material, exists bool) {
	v := m.material
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterial returns the old "material" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldMaterial(ctx context.Context) (v badge.Material, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterial: %w", err)
	}
	return oldValue.Material, nil
}

// ResetMaterial resets all changes to the "material" field.
func (m *BadgeMutation) ResetMaterial() {
	m.material = nil
}

// SetWearerID sets the "wearer" edge to the Pet entity by id.
func (m *BadgeMutation) SetWearerID(id int) {
	m.wearer = &id
}

// ClearWearer clears the "wearer" edge to the Pet entity.
func (m *BadgeMutation) ClearWearer() {
	m.clearedwearer = true
}

// WearerCleared reports if the "wearer" edge to the Pet entity was cleared.
func (m *BadgeMutation) WearerCleared() bool {
	return m.clearedwearer
}

// WearerID returns the "wearer" edge ID in the mutation.
func (m *BadgeMutation) WearerID() (id int, exists bool) {
	if m.wearer != nil {
		return *m.wearer, true
	}
	return
}

// WearerIDs returns the "wearer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WearerID instead. It exists only for internal usage by the builders.
func (m *BadgeMutation) WearerIDs() (ids []int) {
	if id := m.wearer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWearer resets all changes to the "wearer" edge.
func (m *BadgeMutation) ResetWearer() {
	m.wearer = nil
	m.clearedwearer = false
}

// Where appends a list predicates to the BadgeMutation builder.
func (m *BadgeMutation) Where(ps ...predicate.Badge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BadgeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BadgeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Badge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BadgeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BadgeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Badge).
func (m *BadgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BadgeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.color != nil {
		fields = append(fields, badge.FieldColor)
	}
	if m.material != nil {
		fields = append(fields, badge.FieldMaterial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BadgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case badge.FieldColor:
		return m.Color()
	case badge.FieldMaterial:
		return m.Material()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BadgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case badge.FieldColor:
		return m.OldColor(ctx)
	case badge.FieldMaterial:
		return m.OldMaterial(ctx)
	}
	return nil, fmt.Errorf("unknown Badge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case badge.FieldColor:
		v, ok := value.(badge.Color)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case badge.FieldMaterial:
		v, ok := value.(badge.Material)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterial(v)
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BadgeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BadgeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Badge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BadgeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BadgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BadgeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Badge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BadgeMutation) ResetField(name string) error {
	switch name {
	case badge.FieldColor:
		m.ResetColor()
		return nil
	case badge.FieldMaterial:
		m.ResetMaterial()
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BadgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.wearer != nil {
		edges = append(edges, badge.EdgeWearer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BadgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case badge.EdgeWearer:
		if id := m.wearer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BadgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BadgeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BadgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwearer {
		edges = append(edges, badge.EdgeWearer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BadgeMutation) EdgeCleared(name string) bool {
	switch name {
	case badge.EdgeWearer:
		return m.clearedwearer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BadgeMutation) ClearEdge(name string) error {
	switch name {
	case badge.EdgeWearer:
		m.ClearWearer()
		return nil
	}
	return fmt.Errorf("unknown Badge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BadgeMutation) ResetEdge(name string) error {
	switch name {
	case badge.EdgeWearer:
		m.ResetWearer()
		return nil
	}
	return fmt.Errorf("unknown Badge edge %s", name)
}

// PetMutation represents an operation that mutates the Pet nodes in the graph.
type PetMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	height             *int
	addheight          *int
	weight             *float64
	addweight          *float64
	castrated          *bool
	name               *string
	birthday           *time.Time
	nicknames          *[]string
	appendnicknames    []string
	sex                *pet.Sex
	chip               *uuid.UUID
	clearedFields      map[string]struct{}
	badge              *uint32
	clearedbadge       bool
	protege            *int
	clearedprotege     bool
	mentor             *int
	clearedmentor      bool
	spouse             *int
	clearedspouse      bool
	toys               map[uuid.UUID]struct{}
	removedtoys        map[uuid.UUID]struct{}
	clearedtoys        bool
	parent             *int
	clearedparent      bool
	children           map[int]struct{}
	removedchildren    map[int]struct{}
	clearedchildren    bool
	play_groups        map[int]struct{}
	removedplay_groups map[int]struct{}
	clearedplay_groups bool
	friends            map[int]struct{}
	removedfriends     map[int]struct{}
	clearedfriends     bool
	done               bool
	oldValue           func(context.Context) (*Pet, error)
	predicates         []predicate.Pet
}

var _ ent.Mutation = (*PetMutation)(nil)

// petOption allows management of the mutation configuration using functional options.
type petOption func(*PetMutation)

// newPetMutation creates new mutation for the Pet entity.
func newPetMutation(c config, op Op, opts ...petOption) *PetMutation {
	m := &PetMutation{
		config:        c,
		op:            op,
		typ:           TypePet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPetID sets the ID field of the mutation.
func withPetID(id int) petOption {
	return func(m *PetMutation) {
		var (
			err   error
			once  sync.Once
			value *Pet
		)
		m.oldValue = func(ctx context.Context) (*Pet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPet sets the old Pet of the mutation.
func withPet(node *Pet) petOption {
	return func(m *PetMutation) {
		m.oldValue = func(context.Context) (*Pet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHeight sets the "height" field.
func (m *PetMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PetMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *PetMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PetMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *PetMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetWeight sets the "weight" field.
func (m *PetMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PetMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *PetMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *PetMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *PetMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[pet.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *PetMutation) WeightCleared() bool {
	_, ok := m.clearedFields[pet.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *PetMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, pet.FieldWeight)
}

// SetCastrated sets the "castrated" field.
func (m *PetMutation) SetCastrated(b bool) {
	m.castrated = &b
}

// Castrated returns the value of the "castrated" field in the mutation.
func (m *PetMutation) Castrated() (r bool, exists bool) {
	v := m.castrated
	if v == nil {
		return
	}
	return *v, true
}

// OldCastrated returns the old "castrated" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldCastrated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCastrated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCastrated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCastrated: %w", err)
	}
	return oldValue.Castrated, nil
}

// ResetCastrated resets all changes to the "castrated" field.
func (m *PetMutation) ResetCastrated() {
	m.castrated = nil
}

// SetName sets the "name" field.
func (m *PetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PetMutation) ResetName() {
	m.name = nil
}

// SetBirthday sets the "birthday" field.
func (m *PetMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *PetMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *PetMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[pet.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *PetMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[pet.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *PetMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, pet.FieldBirthday)
}

// SetNicknames sets the "nicknames" field.
func (m *PetMutation) SetNicknames(s []string) {
	m.nicknames = &s
	m.appendnicknames = nil
}

// Nicknames returns the value of the "nicknames" field in the mutation.
func (m *PetMutation) Nicknames() (r []string, exists bool) {
	v := m.nicknames
	if v == nil {
		return
	}
	return *v, true
}

// OldNicknames returns the old "nicknames" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldNicknames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNicknames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNicknames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNicknames: %w", err)
	}
	return oldValue.Nicknames, nil
}

// AppendNicknames adds s to the "nicknames" field.
func (m *PetMutation) AppendNicknames(s []string) {
	m.appendnicknames = append(m.appendnicknames, s...)
}

// AppendedNicknames returns the list of values that were appended to the "nicknames" field in this mutation.
func (m *PetMutation) AppendedNicknames() ([]string, bool) {
	if len(m.appendnicknames) == 0 {
		return nil, false
	}
	return m.appendnicknames, true
}

// ClearNicknames clears the value of the "nicknames" field.
func (m *PetMutation) ClearNicknames() {
	m.nicknames = nil
	m.appendnicknames = nil
	m.clearedFields[pet.FieldNicknames] = struct{}{}
}

// NicknamesCleared returns if the "nicknames" field was cleared in this mutation.
func (m *PetMutation) NicknamesCleared() bool {
	_, ok := m.clearedFields[pet.FieldNicknames]
	return ok
}

// ResetNicknames resets all changes to the "nicknames" field.
func (m *PetMutation) ResetNicknames() {
	m.nicknames = nil
	m.appendnicknames = nil
	delete(m.clearedFields, pet.FieldNicknames)
}

// SetSex sets the "sex" field.
func (m *PetMutation) SetSex(pe pet.Sex) {
	m.sex = &pe
}

// Sex returns the value of the "sex" field in the mutation.
func (m *PetMutation) Sex() (r pet.Sex, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldSex(ctx context.Context) (v pet.Sex, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *PetMutation) ResetSex() {
	m.sex = nil
}

// SetChip sets the "chip" field.
func (m *PetMutation) SetChip(u uuid.UUID) {
	m.chip = &u
}

// Chip returns the value of the "chip" field in the mutation.
func (m *PetMutation) Chip() (r uuid.UUID, exists bool) {
	v := m.chip
	if v == nil {
		return
	}
	return *v, true
}

// OldChip returns the old "chip" field's value of the Pet entity.
// If the Pet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetMutation) OldChip(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChip: %w", err)
	}
	return oldValue.Chip, nil
}

// ResetChip resets all changes to the "chip" field.
func (m *PetMutation) ResetChip() {
	m.chip = nil
}

// SetBadgeID sets the "badge" edge to the Badge entity by id.
func (m *PetMutation) SetBadgeID(id uint32) {
	m.badge = &id
}

// ClearBadge clears the "badge" edge to the Badge entity.
func (m *PetMutation) ClearBadge() {
	m.clearedbadge = true
}

// BadgeCleared reports if the "badge" edge to the Badge entity was cleared.
func (m *PetMutation) BadgeCleared() bool {
	return m.clearedbadge
}

// BadgeID returns the "badge" edge ID in the mutation.
func (m *PetMutation) BadgeID() (id uint32, exists bool) {
	if m.badge != nil {
		return *m.badge, true
	}
	return
}

// BadgeIDs returns the "badge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BadgeID instead. It exists only for internal usage by the builders.
func (m *PetMutation) BadgeIDs() (ids []uint32) {
	if id := m.badge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBadge resets all changes to the "badge" edge.
func (m *PetMutation) ResetBadge() {
	m.badge = nil
	m.clearedbadge = false
}

// SetProtegeID sets the "protege" edge to the Pet entity by id.
func (m *PetMutation) SetProtegeID(id int) {
	m.protege = &id
}

// ClearProtege clears the "protege" edge to the Pet entity.
func (m *PetMutation) ClearProtege() {
	m.clearedprotege = true
}

// ProtegeCleared reports if the "protege" edge to the Pet entity was cleared.
func (m *PetMutation) ProtegeCleared() bool {
	return m.clearedprotege
}

// ProtegeID returns the "protege" edge ID in the mutation.
func (m *PetMutation) ProtegeID() (id int, exists bool) {
	if m.protege != nil {
		return *m.protege, true
	}
	return
}

// ProtegeIDs returns the "protege" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProtegeID instead. It exists only for internal usage by the builders.
func (m *PetMutation) ProtegeIDs() (ids []int) {
	if id := m.protege; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProtege resets all changes to the "protege" edge.
func (m *PetMutation) ResetProtege() {
	m.protege = nil
	m.clearedprotege = false
}

// SetMentorID sets the "mentor" edge to the Pet entity by id.
func (m *PetMutation) SetMentorID(id int) {
	m.mentor = &id
}

// ClearMentor clears the "mentor" edge to the Pet entity.
func (m *PetMutation) ClearMentor() {
	m.clearedmentor = true
}

// MentorCleared reports if the "mentor" edge to the Pet entity was cleared.
func (m *PetMutation) MentorCleared() bool {
	return m.clearedmentor
}

// MentorID returns the "mentor" edge ID in the mutation.
func (m *PetMutation) MentorID() (id int, exists bool) {
	if m.mentor != nil {
		return *m.mentor, true
	}
	return
}

// MentorIDs returns the "mentor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentorID instead. It exists only for internal usage by the builders.
func (m *PetMutation) MentorIDs() (ids []int) {
	if id := m.mentor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMentor resets all changes to the "mentor" edge.
func (m *PetMutation) ResetMentor() {
	m.mentor = nil
	m.clearedmentor = false
}

// SetSpouseID sets the "spouse" edge to the Pet entity by id.
func (m *PetMutation) SetSpouseID(id int) {
	m.spouse = &id
}

// ClearSpouse clears the "spouse" edge to the Pet entity.
func (m *PetMutation) ClearSpouse() {
	m.clearedspouse = true
}

// SpouseCleared reports if the "spouse" edge to the Pet entity was cleared.
func (m *PetMutation) SpouseCleared() bool {
	return m.clearedspouse
}

// SpouseID returns the "spouse" edge ID in the mutation.
func (m *PetMutation) SpouseID() (id int, exists bool) {
	if m.spouse != nil {
		return *m.spouse, true
	}
	return
}

// SpouseIDs returns the "spouse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpouseID instead. It exists only for internal usage by the builders.
func (m *PetMutation) SpouseIDs() (ids []int) {
	if id := m.spouse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpouse resets all changes to the "spouse" edge.
func (m *PetMutation) ResetSpouse() {
	m.spouse = nil
	m.clearedspouse = false
}

// AddToyIDs adds the "toys" edge to the Toy entity by ids.
func (m *PetMutation) AddToyIDs(ids ...uuid.UUID) {
	if m.toys == nil {
		m.toys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.toys[ids[i]] = struct{}{}
	}
}

// ClearToys clears the "toys" edge to the Toy entity.
func (m *PetMutation) ClearToys() {
	m.clearedtoys = true
}

// ToysCleared reports if the "toys" edge to the Toy entity was cleared.
func (m *PetMutation) ToysCleared() bool {
	return m.clearedtoys
}

// RemoveToyIDs removes the "toys" edge to the Toy entity by IDs.
func (m *PetMutation) RemoveToyIDs(ids ...uuid.UUID) {
	if m.removedtoys == nil {
		m.removedtoys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.toys, ids[i])
		m.removedtoys[ids[i]] = struct{}{}
	}
}

// RemovedToys returns the removed IDs of the "toys" edge to the Toy entity.
func (m *PetMutation) RemovedToysIDs() (ids []uuid.UUID) {
	for id := range m.removedtoys {
		ids = append(ids, id)
	}
	return
}

// ToysIDs returns the "toys" edge IDs in the mutation.
func (m *PetMutation) ToysIDs() (ids []uuid.UUID) {
	for id := range m.toys {
		ids = append(ids, id)
	}
	return
}

// ResetToys resets all changes to the "toys" edge.
func (m *PetMutation) ResetToys() {
	m.toys = nil
	m.clearedtoys = false
	m.removedtoys = nil
}

// SetParentID sets the "parent" edge to the Pet entity by id.
func (m *PetMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Pet entity.
func (m *PetMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Pet entity was cleared.
func (m *PetMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *PetMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *PetMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *PetMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Pet entity by ids.
func (m *PetMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Pet entity.
func (m *PetMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Pet entity was cleared.
func (m *PetMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Pet entity by IDs.
func (m *PetMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Pet entity.
func (m *PetMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *PetMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *PetMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddPlayGroupIDs adds the "play_groups" edge to the PlayGroup entity by ids.
func (m *PetMutation) AddPlayGroupIDs(ids ...int) {
	if m.play_groups == nil {
		m.play_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.play_groups[ids[i]] = struct{}{}
	}
}

// ClearPlayGroups clears the "play_groups" edge to the PlayGroup entity.
func (m *PetMutation) ClearPlayGroups() {
	m.clearedplay_groups = true
}

// PlayGroupsCleared reports if the "play_groups" edge to the PlayGroup entity was cleared.
func (m *PetMutation) PlayGroupsCleared() bool {
	return m.clearedplay_groups
}

// RemovePlayGroupIDs removes the "play_groups" edge to the PlayGroup entity by IDs.
func (m *PetMutation) RemovePlayGroupIDs(ids ...int) {
	if m.removedplay_groups == nil {
		m.removedplay_groups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.play_groups, ids[i])
		m.removedplay_groups[ids[i]] = struct{}{}
	}
}

// RemovedPlayGroups returns the removed IDs of the "play_groups" edge to the PlayGroup entity.
func (m *PetMutation) RemovedPlayGroupsIDs() (ids []int) {
	for id := range m.removedplay_groups {
		ids = append(ids, id)
	}
	return
}

// PlayGroupsIDs returns the "play_groups" edge IDs in the mutation.
func (m *PetMutation) PlayGroupsIDs() (ids []int) {
	for id := range m.play_groups {
		ids = append(ids, id)
	}
	return
}

// ResetPlayGroups resets all changes to the "play_groups" edge.
func (m *PetMutation) ResetPlayGroups() {
	m.play_groups = nil
	m.clearedplay_groups = false
	m.removedplay_groups = nil
}

// AddFriendIDs adds the "friends" edge to the Pet entity by ids.
func (m *PetMutation) AddFriendIDs(ids ...int) {
	if m.friends == nil {
		m.friends = make(map[int]struct{})
	}
	for i := range ids {
		m.friends[ids[i]] = struct{}{}
	}
}

// ClearFriends clears the "friends" edge to the Pet entity.
func (m *PetMutation) ClearFriends() {
	m.clearedfriends = true
}

// FriendsCleared reports if the "friends" edge to the Pet entity was cleared.
func (m *PetMutation) FriendsCleared() bool {
	return m.clearedfriends
}

// RemoveFriendIDs removes the "friends" edge to the Pet entity by IDs.
func (m *PetMutation) RemoveFriendIDs(ids ...int) {
	if m.removedfriends == nil {
		m.removedfriends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.friends, ids[i])
		m.removedfriends[ids[i]] = struct{}{}
	}
}

// RemovedFriends returns the removed IDs of the "friends" edge to the Pet entity.
func (m *PetMutation) RemovedFriendsIDs() (ids []int) {
	for id := range m.removedfriends {
		ids = append(ids, id)
	}
	return
}

// FriendsIDs returns the "friends" edge IDs in the mutation.
func (m *PetMutation) FriendsIDs() (ids []int) {
	for id := range m.friends {
		ids = append(ids, id)
	}
	return
}

// ResetFriends resets all changes to the "friends" edge.
func (m *PetMutation) ResetFriends() {
	m.friends = nil
	m.clearedfriends = false
	m.removedfriends = nil
}

// Where appends a list predicates to the PetMutation builder.
func (m *PetMutation) Where(ps ...predicate.Pet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pet).
func (m *PetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PetMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.height != nil {
		fields = append(fields, pet.FieldHeight)
	}
	if m.weight != nil {
		fields = append(fields, pet.FieldWeight)
	}
	if m.castrated != nil {
		fields = append(fields, pet.FieldCastrated)
	}
	if m.name != nil {
		fields = append(fields, pet.FieldName)
	}
	if m.birthday != nil {
		fields = append(fields, pet.FieldBirthday)
	}
	if m.nicknames != nil {
		fields = append(fields, pet.FieldNicknames)
	}
	if m.sex != nil {
		fields = append(fields, pet.FieldSex)
	}
	if m.chip != nil {
		fields = append(fields, pet.FieldChip)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pet.FieldHeight:
		return m.Height()
	case pet.FieldWeight:
		return m.Weight()
	case pet.FieldCastrated:
		return m.Castrated()
	case pet.FieldName:
		return m.Name()
	case pet.FieldBirthday:
		return m.Birthday()
	case pet.FieldNicknames:
		return m.Nicknames()
	case pet.FieldSex:
		return m.Sex()
	case pet.FieldChip:
		return m.Chip()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pet.FieldHeight:
		return m.OldHeight(ctx)
	case pet.FieldWeight:
		return m.OldWeight(ctx)
	case pet.FieldCastrated:
		return m.OldCastrated(ctx)
	case pet.FieldName:
		return m.OldName(ctx)
	case pet.FieldBirthday:
		return m.OldBirthday(ctx)
	case pet.FieldNicknames:
		return m.OldNicknames(ctx)
	case pet.FieldSex:
		return m.OldSex(ctx)
	case pet.FieldChip:
		return m.OldChip(ctx)
	}
	return nil, fmt.Errorf("unknown Pet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pet.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case pet.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case pet.FieldCastrated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCastrated(v)
		return nil
	case pet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pet.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case pet.FieldNicknames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNicknames(v)
		return nil
	case pet.FieldSex:
		v, ok := value.(pet.Sex)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case pet.FieldChip:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChip(v)
		return nil
	}
	return fmt.Errorf("unknown Pet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PetMutation) AddedFields() []string {
	var fields []string
	if m.addheight != nil {
		fields = append(fields, pet.FieldHeight)
	}
	if m.addweight != nil {
		fields = append(fields, pet.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pet.FieldHeight:
		return m.AddedHeight()
	case pet.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pet.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case pet.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Pet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pet.FieldWeight) {
		fields = append(fields, pet.FieldWeight)
	}
	if m.FieldCleared(pet.FieldBirthday) {
		fields = append(fields, pet.FieldBirthday)
	}
	if m.FieldCleared(pet.FieldNicknames) {
		fields = append(fields, pet.FieldNicknames)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PetMutation) ClearField(name string) error {
	switch name {
	case pet.FieldWeight:
		m.ClearWeight()
		return nil
	case pet.FieldBirthday:
		m.ClearBirthday()
		return nil
	case pet.FieldNicknames:
		m.ClearNicknames()
		return nil
	}
	return fmt.Errorf("unknown Pet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PetMutation) ResetField(name string) error {
	switch name {
	case pet.FieldHeight:
		m.ResetHeight()
		return nil
	case pet.FieldWeight:
		m.ResetWeight()
		return nil
	case pet.FieldCastrated:
		m.ResetCastrated()
		return nil
	case pet.FieldName:
		m.ResetName()
		return nil
	case pet.FieldBirthday:
		m.ResetBirthday()
		return nil
	case pet.FieldNicknames:
		m.ResetNicknames()
		return nil
	case pet.FieldSex:
		m.ResetSex()
		return nil
	case pet.FieldChip:
		m.ResetChip()
		return nil
	}
	return fmt.Errorf("unknown Pet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PetMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.badge != nil {
		edges = append(edges, pet.EdgeBadge)
	}
	if m.protege != nil {
		edges = append(edges, pet.EdgeProtege)
	}
	if m.mentor != nil {
		edges = append(edges, pet.EdgeMentor)
	}
	if m.spouse != nil {
		edges = append(edges, pet.EdgeSpouse)
	}
	if m.toys != nil {
		edges = append(edges, pet.EdgeToys)
	}
	if m.parent != nil {
		edges = append(edges, pet.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, pet.EdgeChildren)
	}
	if m.play_groups != nil {
		edges = append(edges, pet.EdgePlayGroups)
	}
	if m.friends != nil {
		edges = append(edges, pet.EdgeFriends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pet.EdgeBadge:
		if id := m.badge; id != nil {
			return []ent.Value{*id}
		}
	case pet.EdgeProtege:
		if id := m.protege; id != nil {
			return []ent.Value{*id}
		}
	case pet.EdgeMentor:
		if id := m.mentor; id != nil {
			return []ent.Value{*id}
		}
	case pet.EdgeSpouse:
		if id := m.spouse; id != nil {
			return []ent.Value{*id}
		}
	case pet.EdgeToys:
		ids := make([]ent.Value, 0, len(m.toys))
		for id := range m.toys {
			ids = append(ids, id)
		}
		return ids
	case pet.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case pet.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case pet.EdgePlayGroups:
		ids := make([]ent.Value, 0, len(m.play_groups))
		for id := range m.play_groups {
			ids = append(ids, id)
		}
		return ids
	case pet.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.friends))
		for id := range m.friends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedtoys != nil {
		edges = append(edges, pet.EdgeToys)
	}
	if m.removedchildren != nil {
		edges = append(edges, pet.EdgeChildren)
	}
	if m.removedplay_groups != nil {
		edges = append(edges, pet.EdgePlayGroups)
	}
	if m.removedfriends != nil {
		edges = append(edges, pet.EdgeFriends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pet.EdgeToys:
		ids := make([]ent.Value, 0, len(m.removedtoys))
		for id := range m.removedtoys {
			ids = append(ids, id)
		}
		return ids
	case pet.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case pet.EdgePlayGroups:
		ids := make([]ent.Value, 0, len(m.removedplay_groups))
		for id := range m.removedplay_groups {
			ids = append(ids, id)
		}
		return ids
	case pet.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.removedfriends))
		for id := range m.removedfriends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedbadge {
		edges = append(edges, pet.EdgeBadge)
	}
	if m.clearedprotege {
		edges = append(edges, pet.EdgeProtege)
	}
	if m.clearedmentor {
		edges = append(edges, pet.EdgeMentor)
	}
	if m.clearedspouse {
		edges = append(edges, pet.EdgeSpouse)
	}
	if m.clearedtoys {
		edges = append(edges, pet.EdgeToys)
	}
	if m.clearedparent {
		edges = append(edges, pet.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, pet.EdgeChildren)
	}
	if m.clearedplay_groups {
		edges = append(edges, pet.EdgePlayGroups)
	}
	if m.clearedfriends {
		edges = append(edges, pet.EdgeFriends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PetMutation) EdgeCleared(name string) bool {
	switch name {
	case pet.EdgeBadge:
		return m.clearedbadge
	case pet.EdgeProtege:
		return m.clearedprotege
	case pet.EdgeMentor:
		return m.clearedmentor
	case pet.EdgeSpouse:
		return m.clearedspouse
	case pet.EdgeToys:
		return m.clearedtoys
	case pet.EdgeParent:
		return m.clearedparent
	case pet.EdgeChildren:
		return m.clearedchildren
	case pet.EdgePlayGroups:
		return m.clearedplay_groups
	case pet.EdgeFriends:
		return m.clearedfriends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PetMutation) ClearEdge(name string) error {
	switch name {
	case pet.EdgeBadge:
		m.ClearBadge()
		return nil
	case pet.EdgeProtege:
		m.ClearProtege()
		return nil
	case pet.EdgeMentor:
		m.ClearMentor()
		return nil
	case pet.EdgeSpouse:
		m.ClearSpouse()
		return nil
	case pet.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Pet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PetMutation) ResetEdge(name string) error {
	switch name {
	case pet.EdgeBadge:
		m.ResetBadge()
		return nil
	case pet.EdgeProtege:
		m.ResetProtege()
		return nil
	case pet.EdgeMentor:
		m.ResetMentor()
		return nil
	case pet.EdgeSpouse:
		m.ResetSpouse()
		return nil
	case pet.EdgeToys:
		m.ResetToys()
		return nil
	case pet.EdgeParent:
		m.ResetParent()
		return nil
	case pet.EdgeChildren:
		m.ResetChildren()
		return nil
	case pet.EdgePlayGroups:
		m.ResetPlayGroups()
		return nil
	case pet.EdgeFriends:
		m.ResetFriends()
		return nil
	}
	return fmt.Errorf("unknown Pet edge %s", name)
}

// PlayGroupMutation represents an operation that mutates the PlayGroup nodes in the graph.
type PlayGroupMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	title               *string
	description         *string
	weekday             *playgroup.Weekday
	clearedFields       map[string]struct{}
	participants        map[int]struct{}
	removedparticipants map[int]struct{}
	clearedparticipants bool
	done                bool
	oldValue            func(context.Context) (*PlayGroup, error)
	predicates          []predicate.PlayGroup
}

var _ ent.Mutation = (*PlayGroupMutation)(nil)

// playgroupOption allows management of the mutation configuration using functional options.
type playgroupOption func(*PlayGroupMutation)

// newPlayGroupMutation creates new mutation for the PlayGroup entity.
func newPlayGroupMutation(c config, op Op, opts ...playgroupOption) *PlayGroupMutation {
	m := &PlayGroupMutation{
		config:        c,
		op:            op,
		typ:           TypePlayGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayGroupID sets the ID field of the mutation.
func withPlayGroupID(id int) playgroupOption {
	return func(m *PlayGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *PlayGroup
		)
		m.oldValue = func(ctx context.Context) (*PlayGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlayGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayGroup sets the old PlayGroup of the mutation.
func withPlayGroup(node *PlayGroup) playgroupOption {
	return func(m *PlayGroupMutation) {
		m.oldValue = func(context.Context) (*PlayGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlayGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *PlayGroupMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PlayGroupMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PlayGroup entity.
// If the PlayGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayGroupMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PlayGroupMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *PlayGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlayGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlayGroup entity.
// If the PlayGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlayGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[playgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlayGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[playgroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlayGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, playgroup.FieldDescription)
}

// SetWeekday sets the "weekday" field.
func (m *PlayGroupMutation) SetWeekday(pl playgroup.Weekday) {
	m.weekday = &pl
}

// Weekday returns the value of the "weekday" field in the mutation.
func (m *PlayGroupMutation) Weekday() (r playgroup.Weekday, exists bool) {
	v := m.weekday
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekday returns the old "weekday" field's value of the PlayGroup entity.
// If the PlayGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayGroupMutation) OldWeekday(ctx context.Context) (v playgroup.Weekday, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekday: %w", err)
	}
	return oldValue.Weekday, nil
}

// ResetWeekday resets all changes to the "weekday" field.
func (m *PlayGroupMutation) ResetWeekday() {
	m.weekday = nil
}

// AddParticipantIDs adds the "participants" edge to the Pet entity by ids.
func (m *PlayGroupMutation) AddParticipantIDs(ids ...int) {
	if m.participants == nil {
		m.participants = make(map[int]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the Pet entity.
func (m *PlayGroupMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the Pet entity was cleared.
func (m *PlayGroupMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the Pet entity by IDs.
func (m *PlayGroupMutation) RemoveParticipantIDs(ids ...int) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the Pet entity.
func (m *PlayGroupMutation) RemovedParticipantsIDs() (ids []int) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *PlayGroupMutation) ParticipantsIDs() (ids []int) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *PlayGroupMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// Where appends a list predicates to the PlayGroupMutation builder.
func (m *PlayGroupMutation) Where(ps ...predicate.PlayGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlayGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlayGroup).
func (m *PlayGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, playgroup.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, playgroup.FieldDescription)
	}
	if m.weekday != nil {
		fields = append(fields, playgroup.FieldWeekday)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playgroup.FieldTitle:
		return m.Title()
	case playgroup.FieldDescription:
		return m.Description()
	case playgroup.FieldWeekday:
		return m.Weekday()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playgroup.FieldTitle:
		return m.OldTitle(ctx)
	case playgroup.FieldDescription:
		return m.OldDescription(ctx)
	case playgroup.FieldWeekday:
		return m.OldWeekday(ctx)
	}
	return nil, fmt.Errorf("unknown PlayGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playgroup.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case playgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case playgroup.FieldWeekday:
		v, ok := value.(playgroup.Weekday)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekday(v)
		return nil
	}
	return fmt.Errorf("unknown PlayGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlayGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(playgroup.FieldDescription) {
		fields = append(fields, playgroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayGroupMutation) ClearField(name string) error {
	switch name {
	case playgroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PlayGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayGroupMutation) ResetField(name string) error {
	switch name {
	case playgroup.FieldTitle:
		m.ResetTitle()
		return nil
	case playgroup.FieldDescription:
		m.ResetDescription()
		return nil
	case playgroup.FieldWeekday:
		m.ResetWeekday()
		return nil
	}
	return fmt.Errorf("unknown PlayGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.participants != nil {
		edges = append(edges, playgroup.EdgeParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playgroup.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedparticipants != nil {
		edges = append(edges, playgroup.EdgeParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case playgroup.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparticipants {
		edges = append(edges, playgroup.EdgeParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case playgroup.EdgeParticipants:
		return m.clearedparticipants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PlayGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayGroupMutation) ResetEdge(name string) error {
	switch name {
	case playgroup.EdgeParticipants:
		m.ResetParticipants()
		return nil
	}
	return fmt.Errorf("unknown PlayGroup edge %s", name)
}

// ToyMutation represents an operation that mutates the Toy nodes in the graph.
type ToyMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	color         *toy.Color
	material      *toy.Material
	title         *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Toy, error)
	predicates    []predicate.Toy
}

var _ ent.Mutation = (*ToyMutation)(nil)

// toyOption allows management of the mutation configuration using functional options.
type toyOption func(*ToyMutation)

// newToyMutation creates new mutation for the Toy entity.
func newToyMutation(c config, op Op, opts ...toyOption) *ToyMutation {
	m := &ToyMutation{
		config:        c,
		op:            op,
		typ:           TypeToy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToyID sets the ID field of the mutation.
func withToyID(id uuid.UUID) toyOption {
	return func(m *ToyMutation) {
		var (
			err   error
			once  sync.Once
			value *Toy
		)
		m.oldValue = func(ctx context.Context) (*Toy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Toy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToy sets the old Toy of the mutation.
func withToy(node *Toy) toyOption {
	return func(m *ToyMutation) {
		m.oldValue = func(context.Context) (*Toy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Toy entities.
func (m *ToyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Toy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetColor sets the "color" field.
func (m *ToyMutation) SetColor(t toy.Color) {
	m.color = &t
}

// Color returns the value of the "color" field in the mutation.
func (m *ToyMutation) Color() (r toy.Color, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Toy entity.
// If the Toy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToyMutation) OldColor(ctx context.Context) (v toy.Color, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *ToyMutation) ResetColor() {
	m.color = nil
}

// SetMaterial sets the "material" field.
func (m *ToyMutation) SetMaterial(t toy.Material) {
	m.material = &t
}

// Material returns the value of the "material" field in the mutation.
func (m *ToyMutation) Material() (r toy.Material, exists bool) {
	v := m.material
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterial returns the old "material" field's value of the Toy entity.
// If the Toy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToyMutation) OldMaterial(ctx context.Context) (v toy.Material, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterial: %w", err)
	}
	return oldValue.Material, nil
}

// ResetMaterial resets all changes to the "material" field.
func (m *ToyMutation) ResetMaterial() {
	m.material = nil
}

// SetTitle sets the "title" field.
func (m *ToyMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ToyMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Toy entity.
// If the Toy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToyMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ToyMutation) ResetTitle() {
	m.title = nil
}

// SetOwnerID sets the "owner" edge to the Pet entity by id.
func (m *ToyMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Pet entity.
func (m *ToyMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Pet entity was cleared.
func (m *ToyMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ToyMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ToyMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ToyMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ToyMutation builder.
func (m *ToyMutation) Where(ps ...predicate.Toy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Toy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Toy).
func (m *ToyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.color != nil {
		fields = append(fields, toy.FieldColor)
	}
	if m.material != nil {
		fields = append(fields, toy.FieldMaterial)
	}
	if m.title != nil {
		fields = append(fields, toy.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toy.FieldColor:
		return m.Color()
	case toy.FieldMaterial:
		return m.Material()
	case toy.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toy.FieldColor:
		return m.OldColor(ctx)
	case toy.FieldMaterial:
		return m.OldMaterial(ctx)
	case toy.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Toy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toy.FieldColor:
		v, ok := value.(toy.Color)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case toy.FieldMaterial:
		v, ok := value.(toy.Material)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterial(v)
		return nil
	case toy.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Toy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Toy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Toy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToyMutation) ResetField(name string) error {
	switch name {
	case toy.FieldColor:
		m.ResetColor()
		return nil
	case toy.FieldMaterial:
		m.ResetMaterial()
		return nil
	case toy.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Toy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, toy.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case toy.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, toy.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToyMutation) EdgeCleared(name string) bool {
	switch name {
	case toy.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToyMutation) ClearEdge(name string) error {
	switch name {
	case toy.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Toy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToyMutation) ResetEdge(name string) error {
	switch name {
	case toy.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Toy edge %s", name)
}
